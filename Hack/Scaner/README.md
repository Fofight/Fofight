# 端口扫描
![](https://github.com/DataAnalysisTeam/Fofight/blob/master/Hack/Scaner/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F.jpg?raw=true)
# 端口扫描工
|工具名称|编写语言|实现功能|实现原理|索引|释|
|-------|-------|-------|-------|---|---|
|masscan|C|||[Github](https://github.com/robertdavidgraham/masscan)|号称5分钟扫遍互联网|
|zmap||||号称1小时扫遍互联网|
|nmap|||||
|Netcat||||||
|Strobe||||
|Unicornscan|||||
|Zenmap||||
|nast||||
|Knocker||||
|topera||||||
|Scanline||||||
|SuperScan|||||
|X-Scan|||||
|WSCAN||||
|流光|||||


TCP扫描：

    1.TCP connect scan
    2.TCP SYN scan
    3.TCP FIN
    4.TCP reverse ident 
    5.TCP Xmas TREE
    6.TCP NULL
   
UDP扫描：
    
    1.UDP ICMP端口不可达扫描
    2.UDP recvfrom()和write()扫描
    
其他扫描：

    分片扫描 
    FTP跳转扫描
    GOOGLE特殊搜索
    Metasploit
    Dsniff嗅探式工具
    WebShell 服务器木马嗅探工具
    WINNTAutoAttack
    啊D网络工具包
    
    
    
ack扫描：



常见的扫描类型有以下几种：

     

秘密扫描

秘密扫描是一种不被审计工具所检测的扫描技术。
它通常用于在通过普通的防火墙或路由器的筛选（filtering）时隐藏自己。
秘密扫描能躲避IDS、防火墙、包过滤器和日志审计，从而获取目标端口的开放或关闭的信息。由于没有包含TCP 3次握手协议的任何部分，所以无法被记录下来，比半连接扫描更为隐蔽。
但是这种扫描的缺点是扫描结果的不可靠性会增加，而且扫描主机也需要自己构造IP包。现有的秘密扫描有TCP FIN扫描、TCP ACK扫描、NULL扫描、XMAS扫描和SYN/ACK扫描等。 

1、Connect()扫描：

     此扫描试图与每一个TCP端口进行“三次握手”通信。如果能够成功建立接连，则证明端口开发，否则为关闭。准确度很高，但是最容易被防火墙和IDS检测到，并且在目标主机的日志中会记录大量的连接请求以及错误信息。

TCP connect端口扫描服务端与客户端建立连接成功（目标端口开放）的过程：
① Client端发送SYN；
② Server端返回SYN/ACK，表明端口开放；
③ Client端返回ACK，表明连接已建立；
④ Client端主动断开连接。
建立连接成功（目标端口开放）如图所示

TCP connect端口扫描服务端与客户端未建立连接成功（目标端口关闭）过程：
① Client端发送SYN；
② Server端返回RST/ACK，表明端口未开放。
未建立连接成功(目标端口关闭)如图所示。

优点：实现简单，对操作者的权限没有严格要求（有些类型的端口扫描需要操作者具有root权限），系统中的任何用户都有权力使用这个调用，而且如果想要得到从目标端口返回banners信息，也只能采用这一方法。
另一优点是扫描速度快。如果对每个目标端口以线性的方式，使用单独的connect()调用，可以通过同时打开多个套接字，从而加速扫描。
缺点：是会在目标主机的日志记录中留下痕迹，易被发现，并且数据包会被过滤掉。目标主机的logs文件会显示一连串的连接和连接出错的服务信息，并且能很快地使它关闭。

2、SYN扫描：

      扫描器向目标主机的一个端口发送请求连接的SYN包，扫描器在收到SYN/ACK后，不是发送的ACK应答而是发送RST包请求断开连接。这样，三次握手就没有完成，无法建立正常的TCP连接，因此，这次扫描就不会被记录到系统日志中。这种扫描技术一般不会在目标主机上留下扫描痕迹。但是，这种扫描需要有root权限。
   [点击查看原始大小图片]   

端口开放：1、Client发送SYN  2、Server端发送SYN/ACK 3、Client发送RST断开（只需要前两步就可以判断端口开放）

端口关闭：1、Client发送SYN  2、Server端回复RST（表示端口关闭）

优点：SYN扫描要比TCP Connect()扫描隐蔽一些，SYN仅仅需要发送初始的SYN数据包给目标主机，如果端口开放，则相应SYN-ACK数据包；如果关闭，则响应RST数据包；

3、NULL扫描：

反向扫描----原理是将一个没有设置任何标志位的数据包发送给TCP端口，在正常的通信中至少要设置一个标志位，根据FRC 793的要求，在端口关闭的情况下，若收到一个没有设置标志位的数据字段，那么主机应该舍弃这个分段，并发送一个RST数据包，否则不会响应发起扫描的客户端计算机。也就是说，如果TCP端口处于关闭则响应一个RST数据包，若处于开放则无相应。但是应该知道理由NULL扫描要求所有的主机都符合RFC 793规定，但是windows系统主机不遵从RFC 793标准，且只要收到没有设置任何标志位的数据包时，不管端口是处于开放还是关闭都响应一个RST数据包。但是基于Unix(*nix,如Linux)遵从RFC 793标准，所以可以用NULL扫描。   经过上面的分析，我们知道NULL可以辨别某台主机运行的操作系统是什么操作系统，是为windows呢？还是*nix？

端口开放：Client发送Null，server没有响应

端口关闭：1、Client发送NUll   2、Server回复RST

说明：Null扫描和前面的TCP Connect（）和SYN的判断条件正好相反。在前两种扫描中，有响应数据包的表示端口开放，但在NUll扫描中，收到响应数据包表示端口关闭。反向扫描比前两种隐蔽性高些，当精确度也相对低一些。

用途：判断是否为Windows系统还是*nix

4、FIN扫描：

       与NULL有点类似，只是FIN为指示TCP会话结束，在FIN扫描中一个设置了FIN位的数据包被发送后，若响应RST数据包，则表示端口关闭，没有响应则表示开放。此类扫描同样不能准确判断windows系统上端口开发情况。

端口开放：发送FIN，没有响应

端口关闭：1、发送FIN  2、回复RST

5、ACK扫描：

     扫描主机向目标主机发送ACK数据包。根据返回的RST数据包有两种方法可以得到端口的信息。方法一是： 若返回的RST数据包的TTL值小于或等于64，则端口开放，反之端口关闭，如图所示。

6、Xmas-Tree扫描：

通过发送带有下列标志位的tcp数据包

                                URG：指示数据时紧急数据，应立即处理。

                                PSH：强制将数据压入缓冲区。

                                 FIN：在结束TCP会话时使用。

正常情况下，三个标志位不能被同时设置，但在此种扫描中可以用来判断哪些端口关闭还是开放，与上面的反向扫描情况相同，依然不能判断windows平台上的端口。

端口开放：发送URG/PSH/FIN,没有响应

端口关闭：1、发送URG/PSH/FIN,没有响应   2、响应RST

XMAS扫描原理和NULL扫描的类似，将TCP数据包中的ACK、FIN、RST、SYN、URG、PSH标志位置1后发送给目标主机。在目标端口开放的情况下，目标主机将不返回任何信息。

7、Dump扫描：

       也被称为Idle扫描或反向扫描，在扫描主机时应用了第三方僵尸计算机扫描。由僵尸主机向目标主机发送SYN包。目标主机端口开发时回应SYN|ACK，关闭时返回RST，僵尸主机对SYN|ACK回应RST，对RST不做回应。从僵尸主机上进行扫描时，进行的是一个从本地计算机到僵尸主机的、连续的ping操作。查看僵尸主机返回的Echo响应的ID字段，能确定目标主机上哪些端口是开放的还是关闭的。

